# 17. 클라이언트 식별과 쿠키(~ing)

# 개별 접촉

- HTTP는 익명으로 사용되며, 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.
- 현대의 웹사이트들은 개인화된 서비스를 제공하고 싶어한다.
    - 사용자 별 개별인사, 맞춤 추천, 정보, 세션 추적 등으로 사용자를 식별하여 정보를 제공 할 수 있다.

### 사용자 식별 기술

- 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
- 클라이언트 IP주소 추적으로 알아낸 IP주소로 사용자를 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 기술인 뚱뚱한(fat) URL
- 식별 정보를 지속적으로 유지하는 강력하면서도 효율적인 기술인 Cookie

---

# HTTP 헤더

### From

- Type : 요청
- 사용자의 이메일 주소
- 악의적으로 정보를 뽑아 스팸메일을 보낼 수 있으므로, 해당 헤더를 보내는 브라우저는 많지 않다.

### User-Agent

- Type : 요청
- 사용자 브라우저
- 사용자가 사용하고 있는 브라우저의 이름, 버전 어떤 경우에는 사용중인 OS에 대한 정보까지도 알려준다.

### Referer

- Type : 요청
- 사용자가 현재 링크를 타고 온 근원페이지
- 사용자가 요청을 보낸 페이지의 주소를 알려준다.
- 사용자의 정보를 알 순 없지만, 이전에 어떤 페이지를 방문했는지를 알려준다.

### Authorization

- Type : 요청
- 사용자 이름과 비밀번호

### Client-ip

- Type : 확장(요청)
- 클라이언트의 IP 주소

### X-Forwarded-For

- Type : 확장(요청)
- 클라이언트의 IP 주소

### Cookie

- Type: 확장(요청)

---

# 클라이언트 IP 주소

### 클라이언트 IP주소로 사용자 식별시 단점

- IP주소는 사용자가 아닌 컴퓨터의 주소를 가르킨다. 만약, 한 컴퓨터를 다수가 사용한다면 식별 할 수 없다.
- 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인을 하면 동적으로 IP를 할당한다. 로그인 시간에 따라 매번 IP가 변경 될 수 있으므로 식별 할 수 없다.
- 많은 사용자가 네트워크 주소 변환 방화벽을 통해 인터넷을 사용하므로 식별 할 수 없다.
이 NAT(NetWork Address Translation) 장비들은 실제 IP를 방화벽 뒤로 숨긴다.
- HTTP프락시 or 게이트웨이를 거쳐올 경우, 몇몇 프락시들은 기존 IP를 보존하려 Client-ip나 X-Forward-For와 같은 확장 헤더를 사용하는데 모든 프락시들이 이를 사용하진 않으므로 식별 할 수 없다.

### 인트라넷과 같은 제한적인 환경에서는 적절할 수 있다. But….

- 인터넷에서는 IP 주소를 임의로 변경할 수 있기 때문에 문제가 발생 할 수 있다.
    - 클라이언트와 서버 사이에 있는 프락스도 문제가 발생 할 수도 있다.

---

# 사용자 로그인

- 서버는 요청에 대한 응답으로 사용자 정보를 요구할 수 있다.
- 상태코드 `401 Login Requried`를 보내 로그인을 하라는 응답을 보낼 수 있다.
- 하지만, 매번 다른 사이트에 이동할 때마다 로그인을 해야하는 번거로움이 발생한다.
    - 만약, 내가 사용하는 아이디를 누가 선점했다면, 그에 해당하는 사이트의 회원정보를 다 외워야 한다.

---

# 뚱뚱한(fat) URL

- 사용자의 상태정보를 포함하고 있는 URL을 말한다.
- 사용자가 웹사이트를 처음 방문하면 고유 값을 부여해 URL에 계속 달고다니면서 사용자를 추적한다.
- 아래의 경우 `002-1145265-8016838` 를 통해 사용자를 뚱뚱한 URL로 추적하고 있다.

```html
<a href="/exec/obid/sdff/ref=gr-sdf/002-1145265-8016838">h</a>
<a href="/exec/obid/sdff/ref=gr-sdf/dfdf/002-1145265-8016838">kk</a>
<a href="/exec/obid/sdff/ref=gr-sdf/sfdf/ttt/002-1145265-8016838">sdlkfj</a>
...
```

### 단점

- **못생긴 URL**로 인해 사용자에게 혼란을 준다.
- **공유하지 못하는 URL**로 세션이 없다면 해당 URL로는 정보 공유가 불가능하며 세션이 있다면 정보가 노출됨
- **캐시를 사용할 수 없는 URL**로 URL이 달라지므로 기존 세션이 접근할 수 없게된다.
- **서버 부하를 가중시키는 URL**로 뚱뚱한 URL에 해당하는 HTML페이지를 다시 그려야 한다.
- 기존 서비스에서만 지속되므로 잠시 다른 사이트로 **이탈시 사용이 중지된 URL**이 된다.
- 사용자가 뚱뚱한 URL을 북마킹하지 않는이상!! **로그아웃하면 모든 정보를 잃게 된다.**

---

# Cookie

- 사용자를 식별하는 기술 중 가장 널리 사용중인 기술
- `이름 = 값`의 형태를 가진다.
- 웹서버가 `Set-Cookie`, `Set-Cookie2(확장헤더)`로 HTTP 응답 헤더에 기술되어 사용자에게 전달한다.
- 각각의 브라우저 마다 저장 방법을 달리 한다.
    - **크롬**
        
        → Cookies라는 SQLite 파일에 쿠키를 저장한다.
        
        → Cookie 한 개에 13개의 필드가 존재한다.
        
    - **마이크로소프트 인터넷 익스플로러**
        
        → Cache 디렉터리에 각각의 개별 파일로 쿠키를 저장한다.
        
        쿠키를 확인하려면 해당 디렉터리를 뒤져 볼 수 있다.
        

### Cookie 타입

- **세션쿠키**
    
    → 사용자가 사이트를 탐색 할 때 설정한 환경, 선호 사항들을 저장하는 임시쿠키
    
    → 브라우저를 닫으면 삭제된다.
    
- **지속쿠키**
    
    → 디스크에 저장하며 브라우저를 닫거나 컴퓨터를 재부팅시에도 여전히 남아 있다.
    
    사용자가 주기적으로 방문하는 사이트에 대한 설정 정보 or 로그인 이름을 유지하기 위해 사용한다.
    
- **두 쿠키의 구분점은 파기 시점이다.**
    - `Discard` 파라미터가 설정되어 있거나 `Exprires` or `Max-Age`가 없으면 세션쿠키다.

### Cookie Box: 클라이언트 측 상태

- **Cookie의 기본적인 발상은 브라우저가 서버의 정보를 저장하고, 서버 접근시 그 정보를 함게 전송하는 것**
- 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이를 **클라이언트 측 상태**라고 한다.
    - Cookie명세서에서의 공식적인 이름은 ‘**HTTP 상태 관리 체계**’라고 한다.

### 사이트마다 각기 다른 Cookie

- 브라우저는 모든 사이트에 Cookie를 보내지 않는다.
    - 실제 콘텐츠보다 큰 바이트를 서버에게 전달하게 되기 때문이다.
    - 서버에 특화된 이름/값 쌍으로 구분되기 때문에 무의미한 데이터가 전송되게 되기 때문이다.
    - 신뢰하지 않는 사이트에 개인정보고 유출될 우려가 있기 때문이다.
- `Set-Cookie` 응답헤더에 `Domain` 속성을 통해 특정 사이트에만 Cookie를 보내게 할 수 있다.
- `Set-Cookie` 응답헤더에 `Path` 속성을 통해 해당 `Domain`의 특정 페이지에만 Cookie를 전달할 수 있게 설정할 수 있다.
